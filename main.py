import inspect
from collections import namedtuple
import os
import asyncio
import re
import hashlib
import emoji
import regex
import nest_asyncio
from time import time as now_ts
from datetime import datetime, timedelta
from io import BytesIO

from aiohttp import web
from PIL import Image
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    MessageHandler,
    CommandHandler,
    CallbackQueryHandler,
    filters,
    ContextTypes,
    ConversationHandler,
)
from telegram import BotCommand

import pymorphy2
from pymongo import MongoClient

# ===================== –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã / –≥–ª–æ–±–∞–ª–∫–∏ =====================

# –ß–∞—Ç—ã, –≥–¥–µ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤–∞—Ç–∞—Ä–∫–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∞
EXCLUDE_NSFW_CHAT_IDS = {-1001497970298}

# –ö—ç—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ skin-ratio –¥–ª—è –∞–≤–∞—Ç–∞—Ä–æ–∫: user_id -> (ts, ratio)
AVATAR_CACHE: dict[int, tuple[float, float]] = {}
AVATAR_NSFW_TTL = 24 * 3600  # 24h

PHRASE_HASH_MAP: dict[str, str] = {}

ArgSpec = namedtuple("ArgSpec", "args varargs keywords defaults")
def fix_getargspec(func):
    spec = inspect.getfullargspec(func)
    return ArgSpec(args=spec.args, varargs=spec.varargs, keywords=spec.varkw, defaults=spec.defaults)
inspect.getargspec = fix_getargspec

morph = pymorphy2.MorphAnalyzer()
nest_asyncio.apply()

MONGO_URI = os.getenv("MONGODB_URI")
client = MongoClient(MONGO_URI)
db = client["antispam"]
config_col = db["config"]
banned_col = db["banned_messages"]

ADMIN_CHAT_ID = 296920330

menu_keyboard = ReplyKeyboardMarkup(
    [["/addspam", "/spamlist"], ["/analyze", "/analyzeone"]],
    resize_keyboard=True,
    one_time_keyboard=False,
)

# ===================== –£—Ç–∏–ª–∏—Ç—ã =====================

def is_spam_like(phrase: str, banned_words: list[str], stop_phrases: list[str]) -> bool:
    words = set((phrase or "").lower().split())
    for bw in banned_words:
        if bw.lower() in words:
            return True
    for sp in stop_phrases:
        if sp.lower() in (phrase or "").lower():
            return True
    return False

def is_only_emojis(text: str) -> bool:
    stripped = (text or "").strip()
    if not stripped:
        return False
    return all(ch in emoji.EMOJI_DATA for ch in stripped)

def get_tyumen_time():
    return (datetime.utcnow() + timedelta(hours=5)).strftime("%Y-%m-%d %H:%M:%S")

def normalize_text(text: str) -> str:
    mapping = {'a':'–∞','c':'—Å','e':'–µ','o':'–æ','p':'—Ä','y':'—É','x':'—Ö','3':'–∑','0':'–æ'}
    return "".join(mapping.get(ch, ch) for ch in (text or "").lower())

def lemmatize_text(text: str) -> str:
    return " ".join(morph.parse(w)[0].normal_form for w in (text or "").split())

async def send_admin_notification(bot, text: str):
    try:
        await bot.send_message(chat_id=ADMIN_CHAT_ID, text=text)
    except Exception as e:
        print("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–¥–º–∏–Ω—É:", e)

def load_config():
    doc = config_col.find_one({"_id": "main"})
    if doc:
        doc.pop("_id", None)
        return doc
    return {
        "BANNED_FULL_NAMES": [],
        "PERMANENT_BLOCK_PHRASES": [],
        "COMBINED_BLOCKS": [],
        "BANNED_SYMBOLS": [],
        "BANNED_NAME_SUBSTRINGS": [],
        "BANNED_WORDS": [],
        "BANNED_USERNAME_SUBSTRINGS": [],
    }

def save_config(cfg):
    config_col.replace_one({"_id": "main"}, {**cfg, "_id": "main"}, upsert=True)

def add_banned_message(text: str):
    banned_col.insert_one({"text": text, "time": datetime.utcnow()})

def analyze_banned_messages(cfg, min_count=2):
    all_msgs = [doc.get("text", "") for doc in banned_col.find()]
    words = []
    for msg in all_msgs:
        words += re.findall(r'\b[\w\d\-\_]+\b', (msg or "").lower())
    stop_words = set(map(str.lower, cfg.get("BANNED_WORDS", [])))
    freq = {}
    for w in words:
        if w in stop_words or len(w) < 4:
            continue
        freq[w] = freq.get(w, 0) + 1
    return [w for w, c in freq.items() if c >= min_count]

# ===================== –ê–≤–∞—Ç–∞—Ä—ã: skin-ratio =====================

async def _fetch_biggest_avatar(user_id: int, bot):
    photos = await bot.get_user_profile_photos(user_id, limit=1)
    if not photos or photos.total_count == 0:
        return None
    file_id = photos.photos[0][-1].file_id  # —Å–∞–º—ã–π –∫—Ä—É–ø–Ω—ã–π —Ä–∞–∑–º–µ—Ä
    f = await bot.get_file(file_id)
    buf = BytesIO()
    await f.download_to_memory(out=buf)
    buf.seek(0)
    return buf

def _skin_ratio(img: Image.Image) -> float:
    small = img.resize((256, 256)).convert("YCbCr")
    pixels = small.getdata()
    total = len(pixels)
    skin = 0
    for (y, cb, cr) in pixels:
        if 80 <= cb <= 135 and 135 <= cr <= 180:
            skin += 1
    return skin / max(total, 1)

async def avatar_skin_ratio(user_id: int, bot) -> float:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–æ–ª—é '–∫–æ–∂–∏' –Ω–∞ –∞–≤–∞—Ç–∞—Ä–∫–µ (0..1). –õ—é–±—ã–µ –æ—à–∏–±–∫–∏ -> 0.0
    –†–µ–∑—É–ª—å—Ç–∞—Ç –∫—ç—à–∏—Ä—É–µ—Ç—Å—è –Ω–∞ 24 —á–∞—Å–∞.
    """
    ts = now_ts()
    cached = AVATAR_CACHE.get(user_id)
    if cached and (ts - cached[0] < AVATAR_NSFW_TTL):
        return cached[1]
    try:
        bio = await _fetch_biggest_avatar(user_id, bot)
        if not bio:
            AVATAR_CACHE[user_id] = (ts, 0.0)
            return 0.0
        img = Image.open(bio).convert("RGB")
        ratio = _skin_ratio(img)
        AVATAR_CACHE[user_id] = (ts, ratio)
        return ratio
    except Exception as e:
        print("avatar_skin_ratio error:", e)
        AVATAR_CACHE[user_id] = (ts, 0.0)
        return 0.0

def avatar_decision(ratio: float) -> str:
    """
    'hard' | 'soft' | 'ok'
    –ü–æ—Ä–æ–≥–∏ –º–æ–∂–Ω–æ –ø–æ–¥—Å—Ç—Ä–æ–∏—Ç—å –ø–æ–¥ —Å–≤–æ—é –≥—Ä—É–ø–ø—É.
    """
    HARD = 0.58
    SOFT = 0.42
    if ratio >= HARD:
        return "hard"
    if ratio >= SOFT:
        return "soft"
    return "ok"

# ===================== –•—ç–Ω–¥–ª–µ—Ä—ã –∫–æ–º–∞–Ω–¥ =====================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –î–ª—è –º–µ–Ω—é –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ /menu",
        reply_markup=menu_keyboard
    )

async def menu_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n"
        "/addspam ‚Äî –¥–æ–±–∞–≤–∏—Ç—å —Å–ø–∞–º-—Å–ª–æ–≤–æ/—Ñ—Ä–∞–∑—É\n"
        "/spamlist ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–π —Å—Ç–æ–ø-–ª–∏—Å—Ç\n"
        "/analyzeone ‚Äî –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ\n"
        "/analyze ‚Äî –∞–Ω–∞–ª–∏–∑ —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏—Ö—Å—è —Å–ª–æ–≤\n"
    )
    await update.message.reply_text(text, parse_mode=ParseMode.HTML)

async def spamlist(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.from_user.id != ADMIN_CHAT_ID:
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return
    cfg = load_config()
    text = (
        "<b>BANNED_WORDS</b>:\n" + "\n".join(cfg.get("BANNED_WORDS", [])) + "\n\n"
        "<b>BANNED_FULL_NAMES</b>:\n" + "\n".join(cfg.get("BANNED_FULL_NAMES", [])) + "\n\n"
        "<b>BANNED_SYMBOLS</b>:\n" + " ".join(cfg.get("BANNED_SYMBOLS", [])) + "\n\n"
        "<b>BANNED_NAME_SUBSTRINGS</b>:\n" + "\n".join(cfg.get("BANNED_NAME_SUBSTRINGS", [])) + "\n\n"
        "<b>PERMANENT_BLOCK_PHRASES</b>:\n" + "\n".join(cfg.get("PERMANENT_BLOCK_PHRASES", [])) + "\n\n"
        "<b>COMBINED_BLOCKS</b>:\n" + "\n".join([', '.join(block) for block in cfg.get("COMBINED_BLOCKS", [])])
    )
    await update.message.reply_text(text, parse_mode=ParseMode.HTML, disable_web_page_preview=True)

async def analyze_banned(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.from_user.id != ADMIN_CHAT_ID:
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return
    cfg = load_config()
    candidates = analyze_banned_messages(cfg)
    if not candidates:
        await update.message.reply_text("–ù–µ—Ç –Ω–æ–≤—ã—Ö —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏—Ö—Å—è —Å–ª–æ–≤.")
        return
    await update.message.reply_text("–ß–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏–µ—Å—è –Ω–æ–≤—ã–µ —Å–ª–æ–≤–∞:\n" + "\n".join(candidates))

# --- /analyzeone: –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä —Ñ—Ä–∞–∑ —Å —Ö—ç—à–∞–º–∏ ---
async def analyzeone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.from_user.id != ADMIN_CHAT_ID:
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return

    if not context.args:
        await update.message.reply_text("–ö–∏–Ω—å —Ç–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã.")
        return

    text = " ".join(context.args)
    cfg = load_config()
    stop_phrases = cfg.get("PERMANENT_BLOCK_PHRASES", [])

    parts = re.split(r"[.,;:\-!?]", text)
    candidates = [
        p.strip() for p in parts
        if len(p.strip()) >= 10 and p.strip() not in stop_phrases
    ]
    if not candidates:
        await update.message.reply_text("–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –Ω–æ–≤—ã—Ö —Ñ—Ä–∞–∑ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è.")
        return

    keyboard = []
    PHRASE_HASH_MAP.clear()
    for c in candidates:
        sh = hashlib.sha1(c.encode()).hexdigest()[:8]
        PHRASE_HASH_MAP[sh] = c
        keyboard.append([InlineKeyboardButton(text=f"‚òê {c}", callback_data=f"toggle_{sh}_0")])
    keyboard.append([InlineKeyboardButton("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_phrases")])

    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏ —Ñ—Ä–∞–∑—ã –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ —Å—Ç–æ–ø-–ª–∏—Å—Ç (–º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ):",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    context.user_data["selected_phrases"] = set()

async def select_phrase_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    data = query.data or ""

    if data.startswith("toggle_"):
        parts = data.split("_")
        sh = parts[1]
        selected_flag = parts[2] == "1"

        selected = context.user_data.get("selected_phrases", set())
        if not selected_flag:
            selected.add(sh)
        else:
            selected.discard(sh)
        context.user_data["selected_phrases"] = selected

        keyboard = []
        for k, phrase in PHRASE_HASH_MAP.items():
            checked = "‚òëÔ∏è" if k in selected else "‚òê"
            cb_sel = "1" if k in selected else "0"
            keyboard.append([InlineKeyboardButton(text=f"{checked} {phrase}", callback_data=f"toggle_{k}_{cb_sel}")])
        keyboard.append([InlineKeyboardButton("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_phrases")])
        await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard))
        return

    if data == "confirm_phrases":
        selected = context.user_data.get("selected_phrases", set())
        if not selected:
            await query.answer("–ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ.")
            return
        cfg = load_config()
        to_add = [PHRASE_HASH_MAP[s] for s in selected if s in PHRASE_HASH_MAP]
        for phrase in to_add:
            if phrase not in cfg.get("PERMANENT_BLOCK_PHRASES", []):
                cfg.setdefault("PERMANENT_BLOCK_PHRASES", []).append(phrase)
        save_config(cfg)
        await query.edit_message_text("–§—Ä–∞–∑—ã –¥–æ–±–∞–≤–ª–µ–Ω—ã:\n" + "\n".join(to_add))
        context.user_data["selected_phrases"] = set()
        return

# ===================== –•—ç–Ω–¥–ª–µ—Ä—ã –∞–Ω—Ç–∏—Å–ø–∞–º–∞ =====================

async def delete_spam_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message or update.channel_post
    if not msg:
        return

    # 0) –°–æ–æ–±—â–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –∏–∑ —ç–º–æ–¥–∑–∏ ‚Äî —É–¥–∞–ª—è–µ–º
    if msg.text and is_only_emojis(msg.text):
        try:
            await context.bot.delete_message(chat_id=msg.chat.id, message_id=msg.message_id)
        except Exception:
            pass
        return

    user = msg.from_user
    text = msg.text or ""
    cfg = load_config()
    proc_text = lemmatize_text(normalize_text(text))

    # 1) –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤–∞—Ç–∞—Ä–∞ (–∫—Ä–æ–º–µ –∏—Å–∫–ª—é—á—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤)
    if msg.chat and msg.chat.id not in EXCLUDE_NSFW_CHAT_IDS:
        try:
            ratio = await avatar_skin_ratio(user.id, context.bot)
            decision = avatar_decision(ratio)
            if decision == "hard":
                try:
                    await context.bot.delete_message(chat_id=msg.chat.id, message_id=msg.message_id)
                except Exception:
                    pass
                try:
                    await context.bot.ban_chat_member(chat_id=msg.chat.id, user_id=user.id)
                except Exception:
                    pass
                await send_admin_notification(
                    context.bot,
                    f"–ë–ê–ù –ø–æ –∞–≤–∞—Ç–∞—Ä–∫–µ (skin_ratio={ratio:.2f}): @{user.username or user.first_name} ({user.id})"
                )
                return
            elif decision == "soft":
                await send_admin_notification(
                    context.bot,
                    f"–ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï –ø–æ –∞–≤–∞—Ç–∞—Ä–∫–µ (skin_ratio={ratio:.2f}): @{user.username or user.first_name} ({user.id})"
                )
        except Exception as e:
            print("avatar check in message failed:", e)

    # 2) –ù–∏–∫ —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ —ç–º–æ–¥–∑–∏ –ø–æ –∫—Ä–∞—è–º -> –±–∞–Ω
    name = (user.first_name or "") + (f" {user.last_name}" if user.last_name else "")
    match = regex.match(r"^(?P<emoji>\X)\s?.+\s?(?P=emoji)$", name, flags=regex.UNICODE)
    if match and len(match.group("emoji")) > 0:
        try:
            await context.bot.delete_message(chat_id=msg.chat.id, message_id=msg.message_id)
        except Exception:
            pass
        try:
            await context.bot.ban_chat_member(chat_id=msg.chat.id, user_id=user.id)
        except Exception:
            pass
        return

    # 3) –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
    full_name = (user.first_name or "") + (f" | {user.last_name}" if user.last_name else "")
    clean_name = re.sub(r'[\uFE00-\uFE0F\u200D]', '', full_name)
    name_lower = normalize_text(clean_name)

    ban = False

    if "üíã" in clean_name:
        ban = True

    if not ban:
        for substr in cfg.get("BANNED_NAME_SUBSTRINGS", []):
            if normalize_text(substr) in name_lower:
                ban = True
                break

    if not ban:
        norm_name = lemmatize_text(name_lower)
        banned_norms = [lemmatize_text(normalize_text(n)) for n in cfg.get("BANNED_FULL_NAMES", [])]
        if norm_name in banned_norms:
            ban = True

    if not ban and user.username:
        username_lower = normalize_text(user.username)
        for substr in cfg.get("BANNED_USERNAME_SUBSTRINGS", []):
            if normalize_text(substr) in username_lower:
                ban = True
                break

    if not ban:
        matched = [s for s in cfg.get("BANNED_SYMBOLS", []) if s in clean_name]
        if matched:
            ban = True

    def clean_for_match(s: str) -> str:
        return re.sub(r'[^a-zA-Z–∞-—è–ê-–Ø0-9]', '', (s or '').lower())

    text_raw_clean = clean_for_match(text)
    if not ban:
        for w in cfg.get("BANNED_WORDS", []):
            if clean_for_match(w) in text_raw_clean:
                ban = True
                break

    if not ban:
        for phrase in cfg.get("PERMANENT_BLOCK_PHRASES", []):
            if lemmatize_text(normalize_text(phrase)) in proc_text:
                ban = True
                break

    if not ban:
        for combo in cfg.get("COMBINED_BLOCKS", []):
            if all(lemmatize_text(normalize_text(w)) in proc_text for w in combo):
                ban = True
                break

    if ban:
        try:
            await context.bot.delete_message(chat_id=msg.chat.id, message_id=msg.message_id)
        except Exception:
            pass
        try:
            await context.bot.ban_chat_member(chat_id=msg.chat.id, user_id=user.id)
        except Exception:
            pass
        notif = (
            f"–ó–∞–±–∞–Ω–µ–Ω: @{user.username or user.first_name}\n"
            f"–ò–º—è: {clean_name}\n"
            f"–î–∞—Ç–∞: {get_tyumen_time()}\n"
            f"–°–æ–æ–±—â–µ–Ω–∏–µ: {text}"
        )
        await send_admin_notification(context.bot, notif)
        add_banned_message(text)

# –ù–æ–≤—ã–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏
async def on_new_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return
    chat_id = update.effective_chat.id
    for u in update.message.new_chat_members:
        if chat_id in EXCLUDE_NSFW_CHAT_IDS:
            continue
        try:
            ratio = await avatar_skin_ratio(u.id, context.bot)
            decision = avatar_decision(ratio)
            if decision == "hard":
                try:
                    await context.bot.ban_chat_member(chat_id, u.id)
                except Exception:
                    pass
                await send_admin_notification(
                    context.bot,
                    f"–ë–ê–ù –ø—Ä–∏ –≤—Ö–æ–¥–µ –ø–æ –∞–≤–∞—Ç–∞—Ä–∫–µ (skin_ratio={ratio:.2f}): @{u.username or u.first_name} ({u.id})"
                )
            elif decision == "soft":
                await send_admin_notification(
                    context.bot,
                    f"–ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï –ø—Ä–∏ –≤—Ö–æ–¥–µ (skin_ratio={ratio:.2f}): @{u.username or u.first_name} ({u.id})"
                )
        except Exception as e:
            print("new member avatar check error:", e)

# ===================== addspam –¥–∏–∞–ª–æ–≥ =====================

(ADD_CHOICE, ADD_INPUT, ADD_COMBO) = range(3)

async def addspam_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.from_user.id != ADMIN_CHAT_ID:
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return ConversationHandler.END
    await update.message.reply_text(
        "–ß—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å?\n"
        "1Ô∏è‚É£ –°–ª–æ–≤–æ\n"
        "2Ô∏è‚É£ –§—Ä–∞–∑—É\n"
        "3Ô∏è‚É£ –°–∏–º–≤–æ–ª\n"
        "4Ô∏è‚É£ –ò–º—è\n"
        "5Ô∏è‚É£ –ü–æ–¥—Å—Ç—Ä–æ–∫—É –≤ –∏–º–µ–Ω–∏\n"
        "6Ô∏è‚É£ –ö–æ–º–±–∏–Ω–∞—Ü–∏—é —Å–ª–æ–≤ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)\n"
        "7Ô∏è‚É£ –ü–æ–¥—Å—Ç—Ä–æ–∫—É –≤ username (–Ω–∏–∫–Ω–µ–π–º–µ)\n\n"
        "–û—Ç–ø—Ä–∞–≤—å –Ω–æ–º–µ—Ä (1-7):"
    )
    return ADD_CHOICE

async def addspam_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    choice = update.message.text.strip()
    if choice not in "1234567":
        await update.message.reply_text("–í–≤–µ–¥–∏ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 7.")
        return ADD_CHOICE
    context.user_data["addspam_type"] = int(choice)
    if choice == "6":
        await update.message.reply_text("–í–≤–µ–¥–∏ —Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–ø—Ä–∏–º–µ—Ä: —Ç—Ä–µ–π–¥–∏–Ω–≥, –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏, –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã):")
        return ADD_COMBO
    prompts = [
        "–í–≤–µ–¥–∏ —Å–ª–æ–≤–æ:",
        "–í–≤–µ–¥–∏ —Ñ—Ä–∞–∑—É:",
        "–í–≤–µ–¥–∏ —Å–∏–º–≤–æ–ª:",
        "–í–≤–µ–¥–∏ –∏–º—è –ø–æ–ª–Ω–æ—Å—Ç—å—é:",
        "–í–≤–µ–¥–∏ –ø–æ–¥—Å—Ç—Ä–æ–∫—É –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ –∏–º–µ–Ω–∏:",
        "",  # –¥–ª—è —à–µ—Å—Ç–æ–≥–æ –ø—É–Ω–∫—Ç–∞
        "–í–≤–µ–¥–∏ –ø–æ–¥—Å—Ç—Ä–æ–∫—É –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ username:",
    ]
    await update.message.reply_text(prompts[int(choice)-1])
    return ADD_INPUT

async def addspam_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    value = update.message.text.strip()
    spam_type = context.user_data["addspam_type"]
    cfg = load_config()
    if spam_type == 1:
        cfg.setdefault("BANNED_WORDS", []).append(value)
        await update.message.reply_text(f"–°–ª–æ–≤–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ: {value}")
    elif spam_type == 2:
        cfg.setdefault("PERMANENT_BLOCK_PHRASES", []).append(value)
        await update.message.reply_text(f"–§—Ä–∞–∑–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞: {value}")
    elif spam_type == 3:
        cfg.setdefault("BANNED_SYMBOLS", []).append(value)
        await update.message.reply_text(f"–°–∏–º–≤–æ–ª –¥–æ–±–∞–≤–ª–µ–Ω: {value}")
    elif spam_type == 4:
        cfg.setdefault("BANNED_FULL_NAMES", []).append(value)
        await update.message.reply_text(f"–ò–º—è –¥–æ–±–∞–≤–ª–µ–Ω–æ: {value}")
    elif spam_type == 5:
        cfg.setdefault("BANNED_NAME_SUBSTRINGS", []).append(value)
        await update.message.reply_text(f"–ü–æ–¥—Å—Ç—Ä–æ–∫–∞ –≤ –∏–º–µ–Ω–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞: {value}")
    elif spam_type == 7:
        cfg.setdefault("BANNED_USERNAME_SUBSTRINGS", []).append(value)
        await update.message.reply_text(f"–ü–æ–¥—Å—Ç—Ä–æ–∫–∞ –≤ username –¥–æ–±–∞–≤–ª–µ–Ω–∞: {value}")
    save_config(cfg)
    return ConversationHandler.END

async def addspam_combo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    words = [w.strip() for w in text.split(",") if w.strip()]
    if len(words) < 2:
        await update.message.reply_text("–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º –¥–≤–∞ —Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é.")
        return ADD_COMBO
    cfg = load_config()
    cfg.setdefault("COMBINED_BLOCKS", []).append(words)
    save_config(cfg)
    await update.message.reply_text(f"–ö–æ–º–±–∏–Ω–∞—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞: {', '.join(words)}")
    return ConversationHandler.END

async def cancel_addspam(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ø–∞–º–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    return ConversationHandler.END

addspam_conv = ConversationHandler(
    entry_points=[CommandHandler("addspam", addspam_start)],
    states={
        ADD_CHOICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, addspam_choice)],
        ADD_INPUT:  [MessageHandler(filters.TEXT & ~filters.COMMAND, addspam_input)],
        ADD_COMBO:  [MessageHandler(filters.TEXT & ~filters.COMMAND, addspam_combo)],
    },
    fallbacks=[MessageHandler(filters.COMMAND, cancel_addspam)],
    per_user=True,
)

# ===================== –ü—Ä–æ—á–µ–µ =====================

async def addword_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    word = (query.data or "").replace("addword_", "")
    cfg = load_config()
    if word and word not in cfg.get("BANNED_WORDS", []):
        cfg.setdefault("BANNED_WORDS", []).append(word)
        save_config(cfg)
        await query.answer("–°–ª–æ–≤–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ!")
        await query.edit_message_text(f"–°–ª–æ–≤–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ: {word}")
    else:
        await query.answer("–£–∂–µ –≤ —Å–ø–∏—Å–∫–µ!")

async def set_commands(app):
    commands = [
        BotCommand("addspam", "–î–æ–±–∞–≤–∏—Ç—å —Å–ø–∞–º-—Å–ª–æ–≤–æ/—Ñ—Ä–∞–∑—É"),
        BotCommand("spamlist", "–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–π —Å—Ç–æ–ø-–ª–∏—Å—Ç"),
        BotCommand("analyzeone", "–ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ"),
        BotCommand("start", "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ"),
    ]
    await app.bot.set_my_commands(commands)

# ===================== –í–µ–±-—Å–µ—Ä–≤–µ—Ä / –∑–∞–ø—É—Å–∫ =====================

async def handle_webhook(request, app):
    data = await request.json()
    update = Update.de_json(data, app.bot)
    await app.process_update(update)
    return web.Response(text="OK")

async def init_app():
    port  = int(os.environ.get("PORT", 8443))
    TOKEN = os.getenv("BOT_TOKEN")
    if not TOKEN:
        raise RuntimeError("BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω")
    base = os.getenv("WEBHOOK_URL") or f"https://{os.getenv('RENDER_EXTERNAL_HOSTNAME')}"
    webhook_url = f"{base}/webhook"
    print("üîó Webhook:", webhook_url)

    app = ApplicationBuilder().token(TOKEN).build()
    # –ö–æ–º–∞–Ω–¥—ã/–¥–∏–∞–ª–æ–≥–∏
    app.add_handler(addspam_conv)
    app.add_handler(CommandHandler("spamlist", spamlist))
    app.add_handler(CommandHandler("analyze", analyze_banned))
    app.add_handler(CommandHandler("menu", menu_command))
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("analyzeone", analyzeone))

    # –ö–æ–ª–ª–±—ç–∫–∏ –∫–Ω–æ–ø–æ–∫ –≤—ã–±–æ—Ä–∞ —Ñ—Ä–∞–∑
    app.add_handler(CallbackQueryHandler(select_phrase_callback, pattern="^(toggle_|confirm_phrases)"))
    app.add_handler(CallbackQueryHandler(addword_callback, pattern=r"^addword_"))

    # –ù–æ–≤—ã–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏
    app.add_handler(MessageHandler(filters.StatusUpdate.NEW_CHAT_MEMBERS, on_new_member))

    # –ê–Ω—Ç–∏—Å–ø–∞–º (—Å—Ç–∞–≤—å –≤ —Å–∞–º—ã–π –Ω–∏–∑!)
    app.add_handler(MessageHandler(filters.ALL, delete_spam_message))

    await app.initialize()
    await set_commands(app)
    await app.bot.set_webhook(webhook_url)

    web_app = web.Application()
    web_app.router.add_get("/", lambda r: web.Response(text="OK"))
    web_app.router.add_post("/webhook", lambda r: handle_webhook(r, app))
    return web_app, port

async def main():
    web_app, port = await init_app()
    runner = web.AppRunner(web_app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", port)
    await site.start()
    print(f"üöÄ Running on port {port}")
    while True:
        await asyncio.sleep(3600)

if __name__ == "__main__":
    asyncio.run(main())
